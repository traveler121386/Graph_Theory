# 实验操作指南

本文档详细说明如何执行每个实验，以及每个实验会产生什么结果图和表格。

---

## 📋 目录

1. [项目结构说明](#项目结构说明)
2. [快速开始](#快速开始)
3. [实验环境准备](#实验环境准备)
4. [实验一：网络生成与基本特性验证](#实验一网络生成与基本特性验证)
5. [实验二：中心性指标计算与关键用户识别](#实验二中心性指标计算与关键用户识别)
6. [实验三：社区检测算法对比分析](#实验三社区检测算法对比分析)
7. [实验四：网络规模对算法性能的影响](#实验四网络规模对算法性能的影响)
8. [实验五：交互式系统功能验证](#实验五交互式系统功能验证)
9. [输出文件清单](#输出文件清单)
10. [常见问题](#常见问题)

---

## 📁 项目结构说明

### 核心模块文件

```
NetWork/
├── data_generator.py          # 数据生成模块
├── network_analysis.py        # 网络分析模块
├── community_detection.py      # 社区检测模块
├── visualization.py            # 可视化模块
├── app.py                      # Streamlit交互应用
├── main.py                     # 主程序（完整分析流程）
└── requirements.txt            # 依赖列表
```

### 实验脚本文件

```
NetWork/
├── experiment1.py              # 实验一脚本
├── experiment2.py              # 实验二脚本
├── algorithm_comparison.py     # 实验三脚本（算法对比）
├── performance_test.py         # 实验四脚本（性能测试）
├── plot_performance.py         # 实验四可视化脚本
└── test_experiment5.py         # 实验五脚本（功能测试）
```

### 输出目录结构

```
NetWork/
├── result1/                    # 实验一输出
│   ├── basic_metrics.json
│   ├── 网络基本特性指标表.csv
│   └── 03_degree_distribution.png
├── result2/                    # 实验二输出
│   ├── centrality.csv
│   ├── 用户中心性指标排名表.csv
│   └── 04_centrality_comparison.png
├── result3/                    # 实验三输出
│   ├── 算法对比表.csv
│   ├── 社区统计_Louvain.csv
│   ├── 社区统计_Girvan-Newman.csv
│   └── 社区检测对比表.csv
├── result4/                    # 实验四输出
│   ├── 性能测试结果表.csv
│   ├── 性能测试曲线图.png
│   └── 性能测试单图.png
└── result5/                    # 实验五输出
    ├── 交互式系统功能测试表.csv
    ├── 功能模块统计表.csv
    ├── 测试报告.txt
    ├── 测试结果统计图.png
    └── 响应时间对比图.png
```

**注意**：`results/` 目录是 `main.py` 的默认输出目录，包含完整的分析结果。各实验脚本会输出到对应的 `result1/` 到 `result5/` 目录。

---

## 🚀 快速开始

### 运行所有实验

按顺序运行以下命令：

```bash
# 实验一：网络生成与基本特性验证
python experiment1.py

# 实验二：中心性指标计算与关键用户识别
python experiment2.py

# 实验三：社区检测算法对比分析
python algorithm_comparison.py

# 实验四：网络规模对算法性能的影响
python performance_test.py
python plot_performance.py

# 实验五：交互式系统功能验证
python test_experiment5.py
```

### 一键运行完整分析（可选）

如果想运行完整的分析流程（包含所有功能），可以使用：

```bash
python main.py --nodes 300 --m 3 --seed 42 --out ./results
```

这会生成完整的分析结果到 `results/` 目录。

---

## 🔧 实验环境准备

### 1. 安装依赖

```bash
pip install -r requirements.txt
```

### 2. 验证环境

```bash
python test_modules.py
```

如果所有测试通过，说明环境配置正确。

### 3. Python版本要求

- Python 3.8 及以上版本

---

## 实验一：网络生成与基本特性验证

### 🎯 实验目标

验证BA模型生成网络的无标度特性，确保生成数据符合真实社交网络的统计特征。

### 📝 操作步骤

**运行实验脚本**：

```bash
python experiment1.py
```

### 📊 预期结果

#### 1. 控制台输出

```
================================================================================
实验一：网络生成与基本特性验证
================================================================================

网络参数: 节点数=300, BA参数m=3, 随机种子=42
输出目录: result1/

正在生成网络...
✓ 网络生成完成: 300 个节点, 891 条边

正在进行网络分析...
============================================================
📊 网络基本结构分析
============================================================

基本指标:
  节点数: 300
  边数: 891
  网络密度: 0.0199
  平均度: 5.94
  最大度: 49
  最小度: 3
  平均聚类系数: 0.0728
  平均最短路径长度: 3.01
  网络直径: 5

正在生成度分布图...

================================================================================
✓ 实验一完成！
================================================================================

生成的文件（保存在 result1/ 目录）:
  - basic_metrics.json
  - 网络基本特性指标表.csv
  - 03_degree_distribution.png
================================================================================
```

#### 2. 生成的文件（`result1/` 目录）

| 文件名 | 格式 | 说明 |
|--------|------|------|
| `basic_metrics.json` | JSON | 网络基本指标（完整数据） |
| `网络基本特性指标表.csv` | CSV | 网络基本指标表格（用于论文） |
| `03_degree_distribution.png` | PNG | 度分布图（线性+对数坐标） |

#### 3. 数据表格示例

**网络基本特性指标表.csv**：

| 指标 | 数值 |
|------|------|
| 节点数 | 300 |
| 边数 | 891 |
| 网络密度 | 0.0199 |
| 平均度 | 5.94 |
| 最大度 | 49 |
| 最小度 | 3 |
| 平均聚类系数 | 0.0728 |
| 平均最短路径长度 | 3.01 |
| 网络直径 | 5 |
| 度分布_均值 | 5.94 |
| 度分布_中位数 | 4 |
| 度分布_标准差 | 6.22 |

#### 4. 可视化图片

**`03_degree_distribution.png`**：
- **左图**：度分布直方图（线性坐标）
- **右图**：度分布散点图（对数-对数坐标，验证幂律分布）

### 🔍 结果分析要点

1. **网络密度**：应较低（< 0.05），表明是稀疏网络
2. **度分布**：在对数坐标下应近似为直线，验证幂律分布
3. **小世界特性**：平均最短路径长度应满足 $$\langle l \rangle \sim \log N$$
4. **聚类系数**：应显著高于同等规模的随机网络

---

## 实验二：中心性指标计算与关键用户识别

### 🎯 实验目标

验证多维中心性分析算法的有效性，识别网络中的关键用户，并评估综合中心性评分模型的合理性。

### 📝 操作步骤

**运行实验脚本**：

```bash
python experiment2.py
```

### 📊 预期结果

#### 1. 控制台输出

```
================================================================================
实验二：中心性指标计算与关键用户识别
================================================================================

网络参数: 节点数=300, BA参数m=3, 随机种子=42
输出目录: result2/

正在生成网络...
✓ 网络生成完成

正在计算中心性指标...
============================================================
🎯 关键用户识别 - 网络中心性分析
============================================================

计算度中心性...
计算介数中心性...
计算接近中心性...
计算特征向量中心性...

🌟 排名前10的关键用户:
------------------------------------------------------------

1. User_004
   度中心性: 0.1639 (连接数最多)
   介数中心性: 0.1718 (信息流通枢纽)
   接近中心性: 0.4926 (距离其他用户最近)
   综合排名分数: 0.9978

...（其他用户）

正在生成中心性对比图...

================================================================================
✓ 实验二完成！
================================================================================

生成的文件（保存在 result2/ 目录）:
  - centrality.csv (所有用户的完整数据)
  - 用户中心性指标排名表.csv (前15名)
  - 04_centrality_comparison.png
================================================================================
```

#### 2. 生成的文件（`result2/` 目录）

| 文件名 | 格式 | 说明 |
|--------|------|------|
| `centrality.csv` | CSV | 所有用户的完整中心性数据（300行） |
| `用户中心性指标排名表.csv` | CSV | 排名前15的关键用户表格（用于论文） |
| `04_centrality_comparison.png` | PNG | 中心性对比柱状图 |

#### 3. 数据表格示例

**用户中心性指标排名表.csv**：

| 排名 | 用户 | 度中心性 | 介数中心性 | 接近中心性 | 特征向量中心性 | 综合中心性 |
|------|------|----------|------------|------------|----------------|------------|
| 1 | User_004 | 0.1639 | 0.1718 | 0.4926 | 0.3456 | 0.9978 |
| 2 | User_005 | 0.1538 | 0.1501 | 0.4870 | 0.3123 | 0.9414 |
| 3 | User_006 | 0.1472 | 0.1360 | 0.4672 | 0.2987 | 0.8623 |
| ... | ... | ... | ... | ... | ... | ... |

#### 4. 可视化图片

**`04_centrality_comparison.png`**：
- **X轴**：用户（排名前15）
- **Y轴**：中心性值
- **四个柱状图**：度中心性、介数中心性、接近中心性、综合中心性

### 🔍 结果分析要点

1. **度中心性**：识别"社交明星"（直接连接数最多）
2. **介数中心性**：识别"信息桥梁"（位于不同社区之间）
3. **特征向量中心性**：识别"隐形关键节点"（连接高影响力用户）
4. **综合中心性**：平衡各指标，提供更全面的用户影响力评估

---

## 实验三：社区检测算法对比分析

### 🎯 实验目标

对比Louvain算法与Girvan-Newman算法在社区检测任务上的性能差异，评估模块度优化效果。

### 📝 操作步骤

**运行算法对比脚本**：

```bash
python algorithm_comparison.py
```

**⚠️ 重要说明**：`main.py` 默认只运行 Louvain 算法，不会自动对比。要进行算法对比，必须使用此脚本。

### 📊 预期结果

#### 1. 控制台输出

```
================================================================================
实验三：社区检测算法对比分析
================================================================================
输出目录: result3/

================================================================================
社区检测算法对比实验
================================================================================
网络参数: 节点数=300, BA参数m=3, 随机种子=42

正在生成网络...
✓ 网络生成完成: 300 个节点, 891 条边

================================================================================
算法1: Louvain 算法
================================================================================
✓ Louvain 算法结果:
  - 社区数量: 13
  - 模块度: 0.4234
  - 平均凝聚力: 0.2870
  - 运行时间: 0.230秒

================================================================================
算法2: Girvan-Newman 算法
================================================================================
✓ Girvan-Newman 算法结果:
  - 社区数量: 15
  - 模块度: 0.3892
  - 平均凝聚力: 0.2650
  - 运行时间: 15.670秒

================================================================================
算法对比分析
================================================================================

对比表格:
--------------------------------------------------------------------------------
算法            社区数量      模块度  平均凝聚力  运行时间(秒)
Louvain             13     0.4234     0.2870        0.230
Girvan-Newman       15     0.3892     0.2650       15.670
--------------------------------------------------------------------------------

性能分析:
1. 运行时间对比: Louvain 算法比 Girvan-Newman 快 68.1 倍
2. 模块度对比: Louvain 算法的模块度更高，高出 0.0342
3. 社区凝聚力对比: Louvain 算法的平均凝聚力更高
4. 结论: Louvain 算法在效率和质量上都更优

================================================================================
✓ 实验三完成！
================================================================================

生成的文件（保存在 result3/ 目录）:
  - 算法对比表.csv
  - 社区统计_Louvain.csv
  - 社区统计_Girvan-Newman.csv
  - 社区检测对比表.csv
================================================================================
```

#### 2. 生成的文件（`result3/` 目录）

| 文件名 | 格式 | 说明 |
|--------|------|------|
| `算法对比表.csv` | CSV | **最重要的对比表格**（用于论文） |
| `社区统计_Louvain.csv` | CSV | Louvain算法的详细社区统计 |
| `社区统计_Girvan-Newman.csv` | CSV | Girvan-Newman算法的详细社区统计 |
| `社区检测对比表.csv` | CSV | 社区检测详细统计（Louvain算法） |

#### 3. 数据表格示例

**算法对比表.csv**：

| 算法 | 社区数量 | 模块度 | 平均凝聚力 | 运行时间(秒) |
|------|---------|---------|------------|----------------|
| Louvain | 13 | 0.4234 | 0.2870 | 0.23 |
| Girvan-Newman | 15 | 0.3892 | 0.2650 | 15.67 |

**社区检测对比表.csv**（部分数据）：

| 社区ID | 节点数 | 内部边数 | 外部边数 | 社区密度 | 社区凝聚力 |
|--------|--------|----------|----------|----------|------------|
| C10 | 19 | 31 | 77 | 0.1813 | 0.2870 |
| C0 | 29 | 41 | 110 | 0.1010 | 0.2715 |
| ... | ... | ... | ... | ... | ... |

### 🔍 结果分析要点

1. **模块度对比**：Louvain通常更高（> 0.3表示良好划分）
2. **运行时间对比**：Louvain快得多（适合大规模网络）
3. **社区数量**：两种算法可能不同，需要结合模块度评估
4. **社区凝聚力**：内部边数占比越高，划分越清晰

---

## 实验四：网络规模对算法性能的影响

### 🎯 实验目标

评估系统在不同规模网络下的计算效率与可扩展性，确定系统的性能瓶颈。

### 📝 操作步骤

**步骤1：运行性能测试**

```bash
python performance_test.py
```

**步骤2：生成性能曲线图**

```bash
python plot_performance.py
```

### 📊 预期结果

#### 1. 控制台输出（性能测试）

```
================================================================================
实验四：网络规模对算法性能的影响
================================================================================
输出目录: result4/

================================================================================
网络规模对算法性能的影响测试
================================================================================

测试网络规模: N=100, m=3
  网络生成时间: 0.012秒
  基本指标计算: 0.023秒
  中心性计算: 0.156秒
  社区检测: 0.018秒
  总执行时间: 0.209秒

...（其他规模）

================================================================================
性能测试汇总表
================================================================================
节点数    边数      生成(秒)   基本指标(秒)    中心性(秒)   社区检测(秒)     总时间(秒)  
--------------------------------------------------------------------------------
100       291       0.012      0.023          0.156        0.018           0.209       
200       591       0.025      0.045          0.623        0.034           0.727       
300       891       0.038      0.067          1.456        0.052           1.613       
400       1191      0.052      0.089          2.678        0.071           2.890       
500       1491      0.067      0.112          4.234        0.089           4.502       

性能分析:
中心性计算平均占总时间的比例: 65.2%
结论: 中心性计算是系统的主要性能瓶颈

================================================================================
✓ 实验四完成！
================================================================================

生成的文件（保存在 result4/ 目录）:
  - 性能测试结果表.csv

提示: 运行 python plot_performance.py 生成性能曲线图
================================================================================
```

#### 2. 控制台输出（可视化）

```
================================================================================
实验四：性能测试结果可视化
================================================================================

✓ 找到数据文件: result4/性能测试结果表.csv

数据摘要:
...（显示数据表格）

正在生成综合性能曲线图...
✓ 性能测试曲线图已保存到: result4/性能测试曲线图.png

正在生成单一性能曲线图...
✓ 性能测试单图已保存到: result4/性能测试单图.png

================================================================================
✓ 所有图表生成完成！
================================================================================

生成的文件（保存在 result4/ 目录）:
  - 性能测试曲线图.png (4个子图的综合图)
  - 性能测试单图.png (单一总时间曲线图)
```

#### 3. 生成的文件（`result4/` 目录）

| 文件名 | 格式 | 说明 |
|--------|------|------|
| `性能测试结果表.csv` | CSV | 性能测试数据表格 |
| `性能测试曲线图.png` | PNG | 综合性能分析图（4个子图） |
| `性能测试单图.png` | PNG | 单一总时间曲线图（更简洁） |

#### 4. 数据表格示例

**性能测试结果表.csv**：

| 节点数 | 边数 | 生成时间(秒) | 基本指标(秒) | 中心性(秒) | 社区检测(秒) | 总时间(秒) |
|--------|------|-------------|--------------|------------|--------------|------------|
| 100 | 291 | 0.012 | 0.023 | 0.156 | 0.018 | 0.209 |
| 200 | 591 | 0.025 | 0.045 | 0.623 | 0.034 | 0.727 |
| 300 | 891 | 0.038 | 0.067 | 1.456 | 0.052 | 1.613 |
| 400 | 1191 | 0.052 | 0.089 | 2.678 | 0.071 | 2.890 |
| 500 | 1491 | 0.067 | 0.112 | 4.234 | 0.089 | 4.502 |

#### 5. 可视化图片

**`性能测试曲线图.png`**（包含4个子图）：
- **左上**：总执行时间随网络规模变化曲线
- **右上**：各模块时间分布堆叠面积图
- **左下**：各模块时间对比曲线（多条线）
- **右下**：各模块时间占比堆叠柱状图

**`性能测试单图.png`**：
- 单一的总执行时间曲线图（更简洁，适合论文）

### 🔍 结果分析要点

1. **时间复杂度验证**：
   - 网络生成：$$O(N)$$
   - 基本指标：$$O(N + M)$$
   - 中心性计算：$$O(NM)$$（主要瓶颈）
   - 社区检测：$$O(N \log N)$$

2. **性能瓶颈**：中心性计算通常占总时间的60-70%

3. **可扩展性**：500节点网络总时间约4.5秒，在可接受范围内

---

## 实验五：交互式系统功能验证

### 🎯 实验目标

验证Streamlit交互式应用的功能完整性、用户体验与结果准确性。

### 📝 操作步骤

**方法1：运行自动化测试脚本（推荐）**

```bash
python test_experiment5.py
```

这个脚本会：
- ✅ 自动测试所有功能模块
- ✅ 验证参数调整功能
- ✅ 测试算法选择功能
- ✅ 验证数据展示功能
- ✅ 测试可视化功能
- ✅ 测试交互功能（搜索等）
- ✅ 验证结果一致性
- ✅ 自动生成测试报告和表格
- ✅ 生成可视化图表

**方法2：手动测试Streamlit应用**

```bash
streamlit run app.py
```

在浏览器中手动测试各项功能。

### 📊 预期结果

#### 1. 控制台输出

```
================================================================================
实验五：交互式系统功能验证自动化测试
================================================================================
输出目录: result5/

================================================================================
测试1: 参数调整功能
================================================================================
测试: 节点数量调整（50-500）
  ✓ 正常
测试: BA参数调整（1-10）
  ✓ 正常
测试: 随机种子修改
  ✓ 正常

...（其他测试）

================================================================================
测试完成汇总
================================================================================
总测试数: 15
通过数: 15
失败数: 0

各模块统计:
           通过数  总数  通过率
功能模块                      
参数调整       3     3  100.0
算法选择       4     4  100.0
数据展示       3     3  100.0
网络可视化     2     2  100.0
交互功能       2     2  100.0
结果一致性     1     1  100.0

✓ 所有结果已保存到 result5/ 目录
```

#### 2. 生成的文件（`result5/` 目录）

| 文件名 | 格式 | 说明 |
|--------|------|------|
| `交互式系统功能测试表.csv` | CSV | 详细的功能测试结果表格 |
| `功能模块统计表.csv` | CSV | 各模块的测试通过率统计 |
| `测试报告.txt` | TXT | 完整的文本测试报告 |
| `测试结果统计图.png` | PNG | 测试结果分布和通过率图表 |
| `响应时间对比图.png` | PNG | 各功能响应时间对比图 |
| `网络可视化（社区着色）.png` | PNG | 社区着色网络图 |
| `网络可视化（中心性着色）.png` | PNG | 中心性着色网络图 |

#### 3. 数据表格示例

**交互式系统功能测试表.csv**：

| 功能模块 | 测试项 | 结果 | 响应时间 | 成功率 |
|---------|--------|------|----------|--------|
| 参数调整 | 节点数量调整（50-500） | ✓ 正常 | < 1秒 | 5/5 |
| 参数调整 | BA 参数调整（1-10） | ✓ 正常 | < 1秒 | 5/5 |
| 算法选择 | 自动选择算法 | ✓ 正常 | 1-2秒 | - |
| 算法选择 | Louvain (python-louvain) | ✓ 正常 | 1-2秒 | - |
| 算法选择 | Girvan-Newman | ✓ 正常 | 15-20秒 | - |
| 数据展示 | 网络基本分析 | ✓ 正常 | < 1秒 | - |
| 数据展示 | 关键用户识别 | ✓ 正常 | < 1秒 | - |
| 数据展示 | 社区结构检测 | ✓ 正常 | < 1秒 | - |
| 网络可视化 | 网络可视化（社区着色） | ✓ 正常 | 2-3秒 | - |
| 网络可视化 | 网络可视化（中心性着色） | ✓ 正常 | 2-3秒 | - |
| 交互功能 | 用户搜索（模糊匹配） | ✓ 正常 | 即时 | - |
| 交互功能 | 社区搜索（模糊匹配） | ✓ 正常 | 即时 | - |
| 结果一致性 | 相同参数多次运行结果一致性 | ✓ 一致 | - | - |

**功能模块统计表.csv**：

| 功能模块 | 通过数 | 总数 | 通过率 |
|---------|--------|------|--------|
| 参数调整 | 3 | 3 | 100.0 |
| 算法选择 | 4 | 4 | 100.0 |
| 数据展示 | 3 | 3 | 100.0 |
| 网络可视化 | 2 | 2 | 100.0 |
| 交互功能 | 2 | 2 | 100.0 |
| 结果一致性 | 1 | 1 | 100.0 |

#### 4. 可视化图片

- **`测试结果统计图.png`**：包含2个子图
  - 左图：测试结果分布饼图（通过/失败）
  - 右图：各模块测试通过率柱状图
- **`响应时间对比图.png`**：各功能响应时间横向对比图
- **`网络可视化（社区着色）.png`**：社区着色网络图
- **`网络可视化（中心性着色）.png`**：中心性着色网络图

### 🔍 结果分析要点

1. **功能完整性**：所有设计的功能模块应正常工作
2. **响应性能**：大部分功能响应时间应在3秒以内
3. **结果一致性**：交互式界面结果应与命令行版本一致
4. **用户体验**：界面布局清晰，操作直观

---

## 📁 输出文件清单

### 各实验输出目录

| 实验 | 输出目录 | 主要文件 |
|------|---------|---------|
| 实验一 | `result1/` | basic_metrics.json<br>网络基本特性指标表.csv<br>03_degree_distribution.png |
| 实验二 | `result2/` | centrality.csv<br>用户中心性指标排名表.csv<br>04_centrality_comparison.png |
| 实验三 | `result3/` | 算法对比表.csv<br>社区统计_Louvain.csv<br>社区统计_Girvan-Newman.csv<br>社区检测对比表.csv |
| 实验四 | `result4/` | 性能测试结果表.csv<br>性能测试曲线图.png<br>性能测试单图.png |
| 实验五 | `result5/` | 交互式系统功能测试表.csv<br>功能模块统计表.csv<br>测试报告.txt<br>测试结果统计图.png<br>响应时间对比图.png |

### 完整分析输出（可选）

运行 `python main.py` 后，会在 `results/` 目录下生成完整的分析结果：

| 文件类型 | 文件名 | 说明 |
|---------|--------|------|
| 数据文件 | basic_metrics.json | 网络基本指标 |
| | centrality.csv | 所有用户的中心性数据 |
| | community_stats.csv | 社区统计信息 |
| | report.txt | 综合分析文本报告 |
| 可视化图片 | 01_network_communities.png | 社区着色网络图 |
| | 02_network_centrality.png | 中心性着色网络图 |
| | 03_degree_distribution.png | 度分布图 |
| | 04_centrality_comparison.png | 中心性对比图 |
| | 05_community_statistics.png | 社区统计图 |

---

## ❓ 常见问题

### Q1: 如何修改网络规模？

**A**: 修改实验脚本中的参数，或使用命令行参数（如果支持）：

```python
# 在脚本中修改
n_nodes = 500  # 改为500节点
```

### Q2: 如何修改BA模型参数？

**A**: 修改实验脚本中的 `m` 参数：

```python
m = 5  # 改为5
```

### Q3: 如何确保结果可复现？

**A**: 使用固定的随机种子（`seed=42`），相同参数下结果完全一致。

### Q4: 为什么实验三需要单独运行脚本？

**A**: `main.py` 默认只运行 Louvain 算法。要对比两种算法，必须运行 `algorithm_comparison.py`。

### Q5: Streamlit应用无法启动？

**A**: 确保使用正确的命令：

```bash
streamlit run app.py
```

不要直接运行 `python app.py`。

### Q6: 实验四需要运行两个脚本吗？

**A**: 是的：
1. `performance_test.py` - 生成性能测试数据
2. `plot_performance.py` - 生成性能曲线图

### Q7: 生成的图片在哪里？

**A**: 所有图片保存在对应的 `result1/` 到 `result5/` 目录中。

### Q8: 如何提取特定用户或社区的数据？

**A**: 
- 从 `result2/centrality.csv` 中筛选特定用户
- 从 `result3/社区检测对比表.csv` 中筛选特定社区
- 或使用 Streamlit 应用的搜索功能

---

## 📝 实验报告建议

完成所有实验后，建议按以下结构整理实验报告：

1. **实验环境**：硬件、软件、依赖版本
2. **实验一结果**：网络基本特性指标表 + 度分布图
3. **实验二结果**：用户中心性排名表 + 中心性对比图
4. **实验三结果**：算法对比表 + 社区统计图
5. **实验四结果**：性能测试结果表 + 时间-规模曲线图
6. **实验五结果**：功能测试表 + 界面截图
7. **结果分析**：对每个实验的结果进行详细分析
8. **结论**：总结系统性能和算法效果

---

## 🎯 快速命令参考

```bash
# 实验一
python experiment1.py

# 实验二
python experiment2.py

# 实验三
python algorithm_comparison.py

# 实验四
python performance_test.py
python plot_performance.py

# 实验五
python test_experiment5.py

# 完整分析（可选）
python main.py --nodes 300 --m 3 --seed 42 --out ./results

# 交互式应用
streamlit run app.py
```

---

**最后更新**：2025-12-16
